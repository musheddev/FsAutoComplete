// --------------------------------------------------------------------------------------
// (c) Robin Neatherway
// --------------------------------------------------------------------------------------
namespace FsAutoComplete

module Debug =

  let mutable verbose = false
  let mutable categories : Set<string> option = None

  let mutable output = stderr

  [<Sealed>]
  type Format<'T> private () =
    static let rec mkKn (ty: System.Type) =
      if Reflection.FSharpType.IsFunction(ty) then
          let _, ran = Reflection.FSharpType.GetFunctionElements(ty)
          let f = mkKn ran
          Reflection.FSharpValue.MakeFunction(ty, fun _ -> f)
      else
          box ()

    static let instance : 'T =
      unbox (mkKn typeof<'T>)
    static member Instance = instance

  let inline print (fmt: Printf.TextWriterFormat<'a>) : 'a =
    if verbose then
      fprintfn output fmt
    else
      Format<_>.Instance

  let inline printc cat fmt =
    if verbose && (match categories with
                    | None -> true
                    | Some c -> Set.contains cat c) then
      fprintf  output "[%s] " cat
      fprintfn output fmt
    else
      Format<_>.Instance

  let private startTime = System.DateTime.Now

  let printTiming (fmt: Printf.TextWriterFormat<'a>) : 'a =
    if verbose then
      fprintf  output "%f: " (System.DateTime.Now - startTime).TotalMilliseconds
      fprintfn output fmt
    else
      Format<_>.Instance

  let waitForDebugger () =
    while not(System.Diagnostics.Debugger.IsAttached) do
      System.Threading.Thread.Sleep(100)



  let inline flush () =
    if verbose then
      (output).Flush()


  module FSharpCompilerEventLogger =
    open System.Diagnostics.Tracing

    /// listener for the the events generated by the `FSharp.Compiler.FSharpCompilerEventSource`
    type Listener() =
      inherit EventListener()

      let mutable source = null

      override __.OnEventSourceCreated newSource =
        if newSource.Name = "FSharpCompiler" then
          base.EnableEvents(newSource, EventLevel.LogAlways, EventKeywords.All)
          source <- newSource

      override __.OnEventWritten eventArgs =
        let functionId (o: obj) = o :?> FSharp.Compiler.LogCompilerFunctionId

        let message =
          match eventArgs.EventName with
          | "Log" -> sprintf "Inside Compiler Function %A" (functionId eventArgs.Payload.[0])
          | "LogMessage" -> sprintf "(%A) %s" (functionId eventArgs.Payload.[1]) (eventArgs.Payload.[0] :?> string)
          | "BlockStart" -> sprintf "Started Compiler Function %A" (functionId eventArgs.Payload.[0])
          | "BlockEnd" -> sprintf "Finished Compiler Function %A" (functionId eventArgs.Payload.[0])
          | "BlockMessageStart" -> sprintf "Started Compiler Function %A: %s" (functionId eventArgs.Payload.[1]) (eventArgs.Payload.[0] :?> string)
          | "BlockMessageStop" -> sprintf "Finished Compiler Function %A: %s" (functionId eventArgs.Payload.[1]) (eventArgs.Payload.[0] :?> string)
          | other -> sprintf "Unknown message %s: %A" (eventArgs.EventName) (eventArgs.Payload |> Seq.toList)

        let level = eventArgs.Level

        print "[Compiler]<%O> %s" level message

      interface System.IDisposable with
        member __.Dispose () =
          if isNull source then () else base.DisableEvents(source)
